'use strict';

/**
 * Get logger apis in ToeAgent
 */
var { DBG, ERR, WARN, INFO } = global.getLogger(__filename);

/**
 * Get the Agent class declaration from ToeAgent
 */
var { Agent } = global.getBundledModules();


class Demo1 extends Agent {

    constructor(dummy) {
        super(module);
        this.preferences['ps']['sensor_events'] = [
            'linux::*::cpu::*',
            'sensorboard::*::humidity::*'
        ];
    }

    /**
     * Indicate the Agent is attached to the runtime environment with given `jarvis` helper
     * object to interact with Tac, Tic, and Physical world:
     *
     *   - Tac apps on Android/iOS phones through BLE/WiFi
     *   - Tic apps on PaaS through WAN/Internet/3G/4G connections (via Wstty)
     *   - Physical world near Toe device via Actuators on Peripherals/Boards managed by SensorWeb3
     *
     * After attaching is done, Agent shall invoke the callback function `done` to
     * notify Loader that Agent is ready to execute its own control logics.
     *
     * @jarvis   the instance of Jarvis.
     *
     * @done     the callback function to indicate environment-attaching is done successfully or
     *           failure with error. When fail, the 1st argument `err` shall contain the error object.
     *           When success, the 1st argument `err` shall be `null`.
     */
    attach(jarvis, done) {
        // Write agent's initialization codes here ...
        // 
        this.jarvis = jarvis;
        return done();
    }
  
    /**
     * Indicate the Agent is detached from the runtime environment.
     */
    detach(done) {
        return done();
    }

    /**
     * Notify the Agent instance with a sensor data update event that is registered at
     * Agent initiation phase by specify `ps/sensor_events` field in runtime preference
     * json object.
     *
     * @timestamp  the timestamp object indicates when the sensor data is measured. It can be
     *             null, that indicates the timestamp object shall be generated by the
     *             listener of sensor data update event. There are 3 fields in the timestamp
     *             object: epoch, uptime, and boots.
     *               - epoch , the epoch time on the local Linux system that produces the sensor data event
     *               - uptime, the system uptime of Linux system
     *               - boots , the number of booting up times for the Linux system.
     *
     * @p_type     the type of peripheral (board or machine) associated with the
     *             host/node that runs SensorWeb, e.g. sensorboard, mainboard, echonetlite,
     *             hvac, and so on... The association is either wired (e.g. UART, RS485,
     *             I2C, ...) or wireless (Bluetooth LE, 802.11a/b/g, LoRa, or ZigBee).
     *
     * @p_id       the unique id of the board (or machine) associated with the host/node.
     *             Sometimes, one host/node might associate more than one board with same
     *             type, e.g. A home gateway is associated with 3 BLE coffee machines
     *             in a coffee shop, and use the BLE mac address of each coffee machine
     *             as its unique identity.
     *
     * @s_type     the type of sensor on the board/peripheral (or machine) associated with
     *             the host/node, such as humidity sensor (e.g. st221), ambient light
     *             sensor (e.g. alspt315),dust sensor (e.g. dust), ultrasonic sensor,
     *             and so on.
     *
     * @s_id       the unique id of sensor on the board/peripheral (or machine) associated
     *             with the host/node. The unique identity is used to distigunish 2 sensors
     *             with same type but for different purposes. For example, in a plant box,
     *             there are 2 humidity sensors, one is used to measure humidity/temperature
     *             inside the box while another one is used to measurement same data
     *             outside the box.
     *
     * @data       the dictionary object with all measured data points in form of
     *             key-value pairs. For example, a humidity sensor (st221) can
     *             measure humidity/temperature data, that is represented as
     *             following json object:
     *
     *               ```json
     *               {
     *                 'humidity': 65,
     *                 'temperature': 27.3
     *               }
     *               ```
     *
     *             At SensorWeb3, each peripheral-service can emit a sensor data
     *             update event with data points, as an array of data points and
     *             each data point contains `data_type` and `value` fields. So,
     *             above data object measured by st221 is represented as following
     *             json object in SensorWeb3:
     *
     *               ```json
     *               [
     *                 {"data_type": "humidity"   , value: "65"},
     *                 {"data_type": "temperature", value: "27.3"}
     *               ]
     *               ```
     */
    atSensorUpdated(timestamp, p_type, p_id, s_type, s_id, pp) {
        var self = this;
        var {jarvis} = self;
        INFO(`${JSON.stringify(timestamp)}: ${p_type}/${p_id}/${s_type}/${s_id} => ${JSON.stringify(pp)}`);
        if ((p_type == 'linux') && (s_type == 'cpu')) {
            var percentage = Math.floor(pp['percentage']);
            jarvis.performActuatorAction('sensorboard', 'ttyO1', 'emoji', '_', 'show_number', percentage, null, null, (err) => {
                if (err) {
                    ERR(err, `failed to set emoji to percentage ${percentage}`);
                }
            });
        }
    }
}

module.exports = exports = Demo1;